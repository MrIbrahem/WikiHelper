"""
wikiops/storage.py - Workspace Filesystem Operations Module

This module handles all filesystem operations for WikiHelper workspaces, including:
- Creating, reading, and updating workspace files
- Safe path validation to prevent directory traversal attacks
- Atomic file writes to prevent data corruption
- Workspace listing and metadata management

Security Considerations:
    - All user-provided paths are validated through safe_workspace_path()
    - Windows reserved names (CON, PRN, etc.) are blocked
    - Path traversal attempts (.., /, \\) are rejected
    - File access is restricted to whitelisted workspace files

Concurrency:
    - File writes use atomic operations (write to temp, then rename)
    - No file locking is implemented; concurrent writes may cause issues
    - Consider adding file locking for multi-process deployments

File Encoding:
    - All files are read/written with UTF-8 encoding
    - This is mandatory for handling multilingual WikiText content
"""

from __future__ import annotations

import json
import os
import tempfile
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Final, List, Optional, Tuple

from .utils import fix_some_issues, slugify_title


# Windows reserved filenames that cannot be used as directory names.
# These would cause issues on Windows systems if allowed.
RESERVED_NAMES: Final[set[str]] = {
    "con", "prn", "aux", "nul",
    "com1", "com2", "com3", "com4", "com5", "com6", "com7", "com8", "com9",
    "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9"
}

# Whitelist of files that can be accessed within a workspace.
# This prevents arbitrary file read access.
ALLOWED_WORKSPACE_FILES: Final[set[str]] = {
    "original.wiki",
    "refs.json",
    "editable.wiki",
    "restored.wiki",
    "meta.json"
}

# Type aliases for clarity
WorkspaceInfo = Dict[str, object]


def safe_workspace_path(root: Path, slug: str) -> Optional[Path]:
    """
    Validate and return a safe workspace path within the root directory.

    This function implements defense-in-depth security measures to prevent
    path traversal attacks and ensure the resulting path is safe to use.

    Security Checks Performed:
        1. Path traversal prevention: Blocks "..", "/", and "\\" in slug
        2. Windows reserved names: Blocks CON, PRN, AUX, NUL, COM1-9, LPT1-9
        3. Empty slug rejection
        4. Path resolution verification: Ensures resolved path is within root

    Args:
        root: The root directory under which all workspaces are stored.
              Must be an absolute path (will be resolved).
        slug: The workspace identifier, typically generated by slugify_title().
              Must be a safe string without path separators or traversal attempts.

    Returns:
        The validated absolute Path to the workspace directory if all checks pass.
        None if any security check fails or the path would escape root.

    Example:
        >>> root = Path("/data/workspaces")
        >>> safe_workspace_path(root, "my-article")
        PosixPath('/data/workspaces/my-article')
        >>> safe_workspace_path(root, "../etc/passwd")  # Path traversal attempt
        None
        >>> safe_workspace_path(root, "CON")  # Windows reserved name
        None
    """
    # Check for path traversal attempts.
    # These characters could allow escaping the root directory.
    if ".." in slug or "/" in slug or "\\" in slug:
        return None

    # Check for Windows reserved names that cannot be used as directory names.
    # This ensures cross-platform compatibility.
    if slug.lower() in RESERVED_NAMES:
        return None

    # Reject empty slugs to prevent edge cases.
    if not slug:
        return None

    # Construct the candidate workspace path.
    workspace_path = root / slug

    try:
        # Resolve both paths to absolute form for comparison.
        # resolve() also eliminates any remaining . or .. components.
        resolved = workspace_path.resolve()
        root_resolved = root.resolve()

        # Verify the resolved path is a DIRECT child of root.
        # This prevents cases like "workspace/subdir" from being valid.
        if resolved.parent != root_resolved:
            return None

        return resolved
    except (OSError, ValueError):
        # OSError: Path resolution failed (e.g., permission issues, broken symlinks)
        # ValueError: Invalid path characters on some platforms
        return None


def atomic_write(
    path: Path,
    content: str,
    encoding: str = "utf-8",
    *,
    apply_fixes: bool = True
) -> None:
    """
    Write content to a file atomically using a temporary file.

    Atomic writes prevent data corruption by ensuring that either:
    - The complete new content is written, or
    - The original file remains unchanged

    This is achieved by writing to a temporary file first, then using
    an atomic rename operation to replace the target file.

    Note: A preprocessing step applies fix_some_issues() to content by default.
    This fixes common WikiText formatting issues like section header spacing.

    Args:
        path: The target file path. Parent directories will be created if needed.
        content: The string content to write to the file.
        encoding: The character encoding to use. Defaults to "utf-8" which
                  is mandatory for multilingual WikiText content.
        apply_fixes: If True (default), applies fix_some_issues() to content
                     before writing. Set to False to write content as-is.

    Raises:
        OSError: If file operations fail (permissions, disk full, etc.)
        UnicodeEncodeError: If content cannot be encoded in the specified encoding.

    Warning:
        On Windows, atomic rename may not be truly atomic if the target file
        already exists and is open by another process.
    """
    # Ensure parent directory exists before creating temp file.
    dir_path = path.parent
    dir_path.mkdir(parents=True, exist_ok=True)

    # Apply WikiText formatting fixes if enabled.
    # This corrects common issues like section header spacing.
    if apply_fixes:
        content = fix_some_issues(content)

    # Create temp file in the same directory to ensure atomic rename works.
    # Using the same directory also ensures the temp file is on the same filesystem.
    fd, temp_path = tempfile.mkstemp(dir=str(dir_path), suffix=".tmp")

    try:
        # Write content using the file descriptor.
        # os.fdopen wraps the fd in a Python file object.
        with os.fdopen(fd, "w", encoding=encoding) as f:
            f.write(content)

        # Atomic rename: On POSIX systems, this is atomic within the same filesystem.
        # On Windows, this replaces the target file atomically in most cases.
        os.replace(temp_path, path)
    except Exception:
        # Clean up temp file if anything goes wrong.
        # This prevents orphaned .tmp files from accumulating.
        try:
            os.unlink(temp_path)
        except OSError:
            pass  # Temp file may not exist if fdopen failed
        raise


def read_text(path: Path, encoding: str = "utf-8") -> str:
    """
    Read text content from a file.

    This is a thin wrapper around Path.read_text() with explicit encoding
    to ensure consistent UTF-8 handling across the codebase.

    Args:
        path: The file path to read from.
        encoding: The character encoding to use. Defaults to "utf-8".

    Returns:
        The complete file contents as a string.

    Raises:
        FileNotFoundError: If the file does not exist.
        UnicodeDecodeError: If the file content cannot be decoded.
        PermissionError: If read permission is denied.
    """
    return path.read_text(encoding=encoding)


def read_json(path: Path) -> Dict[str, object]:
    """
    Read and parse JSON content from a file.

    Args:
        path: The path to the JSON file.

    Returns:
        The parsed JSON data as a dictionary.

    Raises:
        FileNotFoundError: If the file does not exist.
        json.JSONDecodeError: If the file contains invalid JSON.
        PermissionError: If read permission is denied.
    """
    content = read_text(path)
    return json.loads(content)


def write_json(path: Path, data: Dict[str, object]) -> None:
    """
    Write dictionary data to a file as formatted JSON.

    The JSON is written with:
    - ensure_ascii=False: Preserves Unicode characters instead of escaping them
    - indent=2: Human-readable formatting with 2-space indentation

    Args:
        path: The target file path.
        data: The dictionary to serialize as JSON.

    Raises:
        OSError: If file operations fail.
        TypeError: If data contains non-JSON-serializable values.
    """
    # ensure_ascii=False is critical for multilingual content.
    # Without it, Arabic/Chinese/etc. characters would be escaped like \u0639\u0631\u0628\u064a
    content = json.dumps(data, ensure_ascii=False, indent=2)
    atomic_write(path, content, apply_fixes=False)


def list_workspaces(root: Path) -> List[WorkspaceInfo]:
    """
    List all workspaces in the root directory, sorted by last modification time.

    This function scans the root directory for valid workspace directories.
    A valid workspace is a directory containing a meta.json file.

    Performance Note: This function reads all meta.json files synchronously.
    For large numbers of workspaces, this could become slow.

    Args:
        root: The root directory containing workspace subdirectories.

    Returns:
        A list of dictionaries, each containing workspace information:
            - slug: The workspace directory name
            - title: The original title from metadata
            - created_at: ISO 8601 timestamp of creation
            - updated_at: ISO 8601 timestamp of last update
            - refs_count: Number of references in the workspace
            - status: Current workspace status ("processing" or "done")
            - path: Path object to the workspace directory

        The list is sorted by updated_at in descending order (most recent first).

    Note:
        Directories without valid meta.json files are silently skipped.
        This provides graceful handling of partially created or corrupted workspaces.
    """
    workspaces: List[WorkspaceInfo] = []

    if not root.exists():
        return workspaces

    for item in root.iterdir():
        if not item.is_dir():
            continue

        meta_path = item / "meta.json"
        if not meta_path.exists():
            continue

        try:
            meta = read_json(meta_path)
            # Build workspace info dict with fallbacks for missing fields
            workspaces.append({
                "slug": item.name,
                "title": meta.get("title_original", item.name),
                "created_at": meta.get("created_at", ""),
                "updated_at": meta.get("updated_at", ""),
                "refs_count": meta.get("refs_count", 0),
                "status": meta.get("status", "processing"),
                "path": item
            })
        except (json.JSONDecodeError, OSError):
            # Skip workspaces with corrupted metadata rather than failing entirely.
            # This allows the application to continue functioning even if
            # some workspaces have corrupted meta.json files.
            pass

    # Sort by updated_at descending (most recent first).
    # Empty strings sort first, so workspaces without timestamps appear at the end.
    workspaces.sort(key=lambda w: w.get("updated_at", ""), reverse=True)

    return workspaces


def create_workspace(
    root: Path,
    title: str,
    wikitext: str
) -> Tuple[str, Path, bool]:
    """
    Create a new workspace or return the existing one if it already exists.

    This function creates the complete workspace file structure:
        - original.wiki: The immutable source WikiText
        - refs.json: The extracted reference map
        - editable.wiki: WikiText with refs replaced by placeholders
        - restored.wiki: Initially identical to original.wiki
        - meta.json: Workspace metadata

    Idempotency: If a workspace with the same slug already exists, the function
    returns the existing workspace without modifying it. The is_new flag indicates
    whether a new workspace was created.

    Args:
        root: The root directory under which to create the workspace.
        title: The human-readable title for the workspace. Will be converted
               to a safe slug for the directory name.
        wikitext: The source WikiText content to process.

    Returns:
        A tuple of (slug, workspace_path, is_new):
            - slug: The safe directory name for the workspace
            - workspace_path: The absolute path to the workspace directory
            - is_new: True if a new workspace was created, False if it existed

    Raises:
        ValueError: If the title cannot be converted to a valid slug,
                    or if the workspace path is invalid.

    Example:
        >>> root = Path("/data/workspaces")
        >>> slug, path, is_new = create_workspace(root, "My Article", "Text<ref>R</ref>")
        >>> is_new
        True
        >>> # Calling again with same title returns existing workspace
        >>> slug, path, is_new = create_workspace(root, "My Article", "Different text")
        >>> is_new
        False
    """
    # Import here to avoid circular dependency at module level.
    from .refs import extract_refs_from_text

    # Convert title to a safe directory name.
    slug = slugify_title(title)
    if not slug:
        raise ValueError("Invalid title: cannot generate a safe slug")

    # Validate the workspace path for security.
    workspace_path = safe_workspace_path(root, slug)
    if workspace_path is None:
        raise ValueError("Invalid workspace path")

    # Check if workspace already exists (idempotency check).
    # We use original.wiki as the sentinel file since it's written first.
    original_path = workspace_path / "original.wiki"
    is_new = not original_path.exists()

    if is_new:
        # Create the workspace directory structure.
        workspace_path.mkdir(parents=True, exist_ok=True)

        # Extract references from the source WikiText.
        editable_text, refs_map = extract_refs_from_text(wikitext)

        # Write original.wiki (immutable source).
        # This file should never be modified after creation.
        atomic_write(original_path, wikitext)

        # Write refs.json (immutable reference data).
        refs_path = workspace_path / "refs.json"
        write_json(refs_path, refs_map)

        # Write editable.wiki (user-editable content with placeholders).
        editable_path = workspace_path / "editable.wiki"
        atomic_write(editable_path, editable_text)

        # Write restored.wiki (initially same as original).
        # This will be regenerated when the user saves edits.
        restored_path = workspace_path / "restored.wiki"
        atomic_write(restored_path, wikitext)

        # Create metadata with ISO 8601 timestamps.
        # Using UTC (Z suffix) ensures consistent timezone handling.
        now = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
        meta: Dict[str, object] = {
            "title_original": title,
            "slug": slug,
            "created_at": now,
            "updated_at": now,
            "status": "processing",
            "refs_count": len(refs_map)
        }
        meta_path = workspace_path / "meta.json"
        write_json(meta_path, meta)

    return slug, workspace_path, is_new


def update_workspace(
    workspace_path: Path,
    editable_content: str,
    status: Optional[str] = None
) -> str:
    """
    Update a workspace's editable content and regenerate the restored WikiText.

    This function:
    1. Writes the new editable content to editable.wiki
    2. Restores references using the stored refs.json
    3. Writes the restored content to restored.wiki
    4. Updates the metadata timestamp and optionally the status

    Args:
        workspace_path: The path to the workspace directory.
        editable_content: The edited WikiText with [refN] placeholders.
        status: Optional new status value. If provided, updates the status
                in meta.json. Common values: "processing", "done".

    Returns:
        The restored WikiText content with references replaced.

    Raises:
        FileNotFoundError: If refs.json does not exist in the workspace.
        json.JSONDecodeError: If refs.json contains invalid JSON.

    Note:
        The refs.json file is never modified; only editable.wiki and
        restored.wiki are updated. This preserves the original reference
        mapping for all future edits.
    """
    # Import here to avoid circular dependency at module level.
    from .refs import restore_refs_in_text

    # Load the immutable reference map.
    refs_path = workspace_path / "refs.json"
    refs_map: Dict[str, str] = read_json(refs_path)  # type: ignore[assignment]

    # Update the user-editable content.
    editable_path = workspace_path / "editable.wiki"
    atomic_write(editable_path, editable_content)

    # Restore references to generate the final output.
    restored_content = restore_refs_in_text(editable_content, refs_map)

    # Write the restored content.
    restored_path = workspace_path / "restored.wiki"
    atomic_write(restored_path, restored_content)

    # Update metadata with new timestamp and optional status change.
    meta_path = workspace_path / "meta.json"
    if meta_path.exists():
        meta = read_json(meta_path)
        meta["updated_at"] = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
        if status:
            meta["status"] = status
        write_json(meta_path, meta)

    return restored_content


def get_workspace_file(workspace_path: Path, filename: str) -> Optional[str]:
    """
    Retrieve the content of a specific file from a workspace.

    This function implements access control by only allowing reads from
    the whitelisted set of workspace files.

    Args:
        workspace_path: The path to the workspace directory.
        filename: The name of the file to read.

    Returns:
        The file contents as a string if the file exists and is allowed.
        None if the file is not in the whitelist or does not exist.

    Security Note:
        The filename whitelist prevents arbitrary file read access within
        the workspace directory. Without this check, an attacker could
        potentially read sensitive files by manipulating the filename.
    """
    if filename not in ALLOWED_WORKSPACE_FILES:
        return None

    file_path = workspace_path / filename
    if not file_path.exists():
        return None

    return read_text(file_path)
